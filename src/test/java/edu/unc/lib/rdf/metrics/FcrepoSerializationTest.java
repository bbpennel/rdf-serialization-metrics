package edu.unc.lib.rdf.metrics;

import static edu.unc.lib.rdf.metrics.ModelUtil.ACCEPT_JSON_LD;
import static edu.unc.lib.rdf.metrics.ModelUtil.ACCEPT_NTRIPLES;
import static edu.unc.lib.rdf.metrics.ModelUtil.ACCEPT_TURTLE;
import static org.apache.jena.rdf.model.ResourceFactory.createProperty;

import java.net.URI;

import org.apache.commons.lang3.time.StopWatch;
import org.apache.jena.rdf.model.Model;
import org.apache.jena.rdf.model.ModelFactory;
import org.apache.jena.rdf.model.Property;
import org.apache.jena.rdf.model.Resource;
import org.apache.jena.riot.RDFFormat;
import org.fcrepo.client.FcrepoClient;
import org.fcrepo.client.FcrepoResponse;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

/**
 * Tests of execution time required to retrieve object metadata from fedora in
 * different serialization formats. Varies the types of properties on the object
 * to measure for differences between many literals, properties to the same
 * object, properties to different objects, properties generated by an indirect
 * container, properties generated by a direct container, and a baseline fedora
 * container with no additional properties added.
 *
 * @author bbpennel
 *
 */
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration({"/spring-test/test-fedora-container.xml"})
public class FcrepoSerializationTest {
    private static final Logger log = LoggerFactory.getLogger(FcrepoSerializationTest.class);

    private FcrepoClient fcrepoClient;
    private LdpContainerFactory containerFactory;

    private static final String URI_BASE = "http://example.com/";
    private static final Property TEST_PROPERTY = createProperty(URI_BASE + "testProperty");

    private final static String FCREPO_BASE = "http://localhost:48085/rest/";
    private final static URI FCREPO_URI = URI.create(FCREPO_BASE);

    private final static int RET_ITERATIONS = 20;

    @Before
    public void init() throws Exception {
        fcrepoClient = FcrepoClient.client().throwExceptionOnFailure().build();
        containerFactory = new LdpContainerFactory();
        containerFactory.setClient(fcrepoClient);
    }

    @Test
    public void testRetrieve() throws Exception {
        String description = "blank";

        URI uri = makeObject(null, null, null);
        warmup(uri);

        retrieveObject(uri, RDFFormat.NTRIPLES, ACCEPT_NTRIPLES, RET_ITERATIONS, description);
        retrieveObject(uri, RDFFormat.JSONLD, ACCEPT_JSON_LD, RET_ITERATIONS, description);
        retrieveObject(uri, RDFFormat.TURTLE, ACCEPT_TURTLE, RET_ITERATIONS, description);
    }

    @Test
    public void testRetrieve100Literals() throws Exception {
        retrieveNLiterals(100, RET_ITERATIONS);
    }

    @Test
    public void testRetrieve1000Literals() throws Exception {
        retrieveNLiterals(1000, RET_ITERATIONS);
    }

    @Test
    public void testRetrieve5000Literals() throws Exception {
        retrieveNLiterals(5000, RET_ITERATIONS);
    }

    @Test
    public void testRetrieve10000Literals() throws Exception {
        retrieveNLiterals(10000, RET_ITERATIONS);
    }

    private void retrieveNLiterals(int numLiterals, int numIterations) throws Exception {
        String description = numLiterals + "_literals";

        Model model = ModelFactory.createDefaultModel();
        Resource resc = model.getResource("");
        for (int i = 0; i < numLiterals; i++) {
            resc.addLiteral(TEST_PROPERTY, "val" + i);
        }

        URI uri = makeObject(model, RDFFormat.TURTLE, "text/turtle");
        warmup(uri);

        retrieveObject(uri, RDFFormat.NTRIPLES, ACCEPT_NTRIPLES, numIterations, description);
        retrieveObject(uri, RDFFormat.JSONLD, ACCEPT_JSON_LD, numIterations, description);
        retrieveObject(uri, RDFFormat.TURTLE, ACCEPT_TURTLE, numIterations, description);
    }

    @Test
    public void testRetrieve100PropertiesToSameObject() throws Exception {
        retrieveNPropertiesToSameObject(100, RET_ITERATIONS);
    }

    @Test
    public void testRetrieve1000PropertiesToSameObject() throws Exception {
        retrieveNPropertiesToSameObject(1000, RET_ITERATIONS);
    }

    @Test
    public void testRetrieve5000PropertiesToSameObject() throws Exception {
        retrieveNPropertiesToSameObject(5000, RET_ITERATIONS);
    }

    @Test
    public void testRetrieve10000PropertiesToSameObject() throws Exception {
        retrieveNPropertiesToSameObject(10000, RET_ITERATIONS);
    }

    private void retrieveNPropertiesToSameObject(int numProps, int numIterations) throws Exception {
        String description = numProps + "_props_same_obj";

        URI objUri = makeObject(null, null, null);

        Model model = ModelFactory.createDefaultModel();
        Resource resc = model.getResource("");
        Resource objResc = model.getResource(objUri.toString());

        for (int i = 0; i < numProps; i++) {
            Property prop = createProperty(URI_BASE + "testProperty" + i);
            resc.addProperty(prop, objResc);
        }

        URI uri = makeObject(model, RDFFormat.TURTLE, "text/turtle");
        warmup(uri);

        retrieveObject(uri, RDFFormat.NTRIPLES, ACCEPT_NTRIPLES, numIterations, description);
        retrieveObject(uri, RDFFormat.JSONLD, ACCEPT_JSON_LD, numIterations, description);
        retrieveObject(uri, RDFFormat.TURTLE, ACCEPT_TURTLE, numIterations, description);
    }

    @Test
    public void testRetrieve100PropertyDifferentObjects() throws Exception {
        retrievePropertyToNObjects(100, RET_ITERATIONS);
    }

    @Test
    public void testRetrieve1000PropertyDifferentObjects() throws Exception {
        retrievePropertyToNObjects(1000, RET_ITERATIONS);
    }

    @Test
    public void testRetrieve5000PropertyDifferentObjects() throws Exception {
        retrievePropertyToNObjects(5000, RET_ITERATIONS);
    }

    @Test
    public void testRetrieve10000PropertyDifferentObjects() throws Exception {
        retrievePropertyToNObjects(10000, RET_ITERATIONS);
    }

    private void retrievePropertyToNObjects(int numProps, int numIterations) throws Exception {
        String description = numProps + "_props_many_objs";

        Model model = ModelFactory.createDefaultModel();
        Resource resc = model.getResource("");

        for (int i = 0; i < numProps; i++) {
            URI objUri = makeObject(null, null, null);
            Resource objResc = model.getResource(objUri.toString());

            resc.addProperty(TEST_PROPERTY, objResc);
        }

        URI uri = makeObject(model, RDFFormat.TURTLE, "text/turtle");
        warmup(uri);

        retrieveObject(uri, RDFFormat.NTRIPLES, ACCEPT_NTRIPLES, numIterations, description);
        retrieveObject(uri, RDFFormat.JSONLD, ACCEPT_JSON_LD, numIterations, description);
        retrieveObject(uri, RDFFormat.TURTLE, ACCEPT_TURTLE, numIterations, description);
    }

    @Test
    public void testRetrieve100Containment() throws Exception {
        retrieveObjectWithNContained(100, RET_ITERATIONS);
    }

    @Test
    public void testRetrieve1000Containment() throws Exception {
        retrieveObjectWithNContained(1000, RET_ITERATIONS);
    }

    @Test
    public void testRetrieve5000Containment() throws Exception {
        retrieveObjectWithNContained(5000, RET_ITERATIONS);
    }

    private void retrieveObjectWithNContained(int numChildren, int numIterations) throws Exception {
        String description = numChildren + "_contains";

        URI uri = makeObject(null, null, null);
        for (int i = 0; i < numChildren; i++) {
            containerFactory.createContainer(uri);
        }

        warmup(uri);

        retrieveObject(uri, RDFFormat.NTRIPLES, ACCEPT_NTRIPLES, numIterations, description);
        retrieveObject(uri, RDFFormat.JSONLD, ACCEPT_JSON_LD, numIterations, description);
        retrieveObject(uri, RDFFormat.TURTLE, ACCEPT_TURTLE, numIterations, description);
    }

    @Test
    public void testRetrieve100IndirectContainer() throws Exception {
        retrieveObjectNIndirectContainment(100, RET_ITERATIONS);
    }

    @Test
    public void testRetrieve1000IndirectContainer() throws Exception {
        retrieveObjectNIndirectContainment(1000, RET_ITERATIONS);
    }

    @Test
    public void testRetrieve5000IndirectContainer() throws Exception {
        retrieveObjectNIndirectContainment(5000, RET_ITERATIONS);
    }

    @Test
    public void testRetrieve10000IndirectContainer() throws Exception {
        retrieveObjectNIndirectContainment(10000, RET_ITERATIONS);
    }

    private void retrieveObjectNIndirectContainment(int numChildren, int numIterations) throws Exception {
        String description = numChildren + "_indirect_contains";

        URI uri = makeObject(null, null, null);
        URI indirectUri = containerFactory.createIndirectContainer(uri, TEST_PROPERTY, "indirect");

        for (int i = 0; i < numChildren; i++) {
            URI childUri = makeObject(null, null, null);
            containerFactory.createIndirectProxy(indirectUri, uri, childUri);
        }

        warmup(uri);

        retrieveObject(uri, RDFFormat.NTRIPLES, ACCEPT_NTRIPLES, numIterations, description);
        retrieveObject(uri, RDFFormat.JSONLD, ACCEPT_JSON_LD, numIterations, description);
        retrieveObject(uri, RDFFormat.TURTLE, ACCEPT_TURTLE, numIterations, description);
    }

    @Test
    public void testRetrieve100DirectContainer() throws Exception {
        retrieveObjectNDirectContainment(100, RET_ITERATIONS);
    }

    @Test
    public void testRetrieve1000DirectContainer() throws Exception {
        retrieveObjectNDirectContainment(1000, RET_ITERATIONS);
    }

    @Test
    public void testRetrieve5000DirectContainer() throws Exception {
        retrieveObjectNDirectContainment(5000, RET_ITERATIONS);
    }

    @Test
    public void testRetrieve10000DirectContainer() throws Exception {
        retrieveObjectNDirectContainment(10000, RET_ITERATIONS);
    }

    private void retrieveObjectNDirectContainment(int numChildren, int numIterations) throws Exception {
        String description = numChildren + "_direct_contains";

        URI uri = makeObject(null, null, null);
        URI directUri = containerFactory.createDirectContainer(uri, TEST_PROPERTY, "direct");

        for (int i = 0; i < numChildren; i++) {
            containerFactory.createContainer(directUri);
        }

        warmup(uri);

        retrieveObject(uri, RDFFormat.NTRIPLES, ACCEPT_NTRIPLES, numIterations, description);
        retrieveObject(uri, RDFFormat.JSONLD, ACCEPT_JSON_LD, numIterations, description);
        retrieveObject(uri, RDFFormat.TURTLE, ACCEPT_TURTLE, numIterations, description);
    }

    private void retrieveObject(URI uri, RDFFormat format, String accept, int iterations, String description)
            throws Exception {
        StopWatch timer = StopWatch.createStarted();

        for (int i = 0; i < iterations; i++) {
            try (FcrepoResponse resp = fcrepoClient.get(uri).accept(accept).perform()) {
                //log.info("{}", IOUtils.toString(resp.getBody(), "UTF-8"));
            }
        }

        timer.stop();
        log.info("Retrieve,{},{},{},{},{},{}", iterations, description, format.toString(),
                timer.getNanoTime() / 1000000, iterations, ((double) timer.getNanoTime() / iterations) / 1000000);
    }

    private URI makeObject(Model model, RDFFormat format, String contentType) throws Exception {
        return containerFactory.createContainer(FCREPO_URI, model, format, contentType);
    }

    private void warmup(URI uri) throws Exception {
        for (int i = 0; i < 10; i++) {
            try (FcrepoResponse resp = fcrepoClient.get(uri).accept("text/plain").perform()) {
            }
        }
    }
}
